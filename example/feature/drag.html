<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Drag</title>
  <style>
    body { margin: 0; }
    canvas { display: block; width: 100vw; height: 100vh; touch-action: none; }
  </style>
</head>

<body>
  <canvas id="game-canvas" width="1200" height="800"></canvas>

  <script type="module">
    import { Engine, Draw } from '../dist/web-ecs.es.js';

    const canvas = document.getElementById('game-canvas');

    // 让 canvas 内部坐标与 CSS 像素一致，保证拾取/事件坐标不飘
    function resizeCanvasToViewport() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resizeCanvasToViewport();
    window.addEventListener('resize', resizeCanvasToViewport);

    const engine = new Engine(canvas);
    const draw = new Draw(engine);

    // 一些可拖拽图形（通过 draw 返回的 instance.event 接收事件）
    const rect = draw.rect(
      { x: 120, y: 120 },
      { width: 240, height: 140, fillStyle: 'rgba(59, 130, 246, 0.35)', strokeStyle: '#111827', lineWidth: 3 }
    );
    engine.root.add(rect);
    const circle = draw.circle(
      { x: 560, y: 200 },
      { radius: 80, fillStyle: 'rgba(34, 197, 94, 0.35)', strokeStyle: '#111827', lineWidth: 3 }
    );
    engine.root.add(circle);
    const polyline = draw.polyline(
      { x: 820, y: 260 },
      {
        points: [
          [0, 0],
          [160, 40],
          [200, 160],
          [60, 220],
        ],
        closed: true,
        fillStyle: 'rgba(239, 68, 68, 0.25)',
        strokeStyle: '#111827',
        lineWidth: 3,
      }
    );
    engine.root.add(polyline);

    let dragging = null;

    function toCanvasXY(e) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      if ('touches' in e && e.touches && e.touches.length > 0) {
        const t = e.touches[0];
        return {
          x: (t.clientX - rect.left) * scaleX,
          y: (t.clientY - rect.top) * scaleY,
        };
      }
      return {
        x: (e.clientX - rect.left) * scaleX,
        y: (e.clientY - rect.top) * scaleY,
      };
    }

    function bindDrag(instance) {
      instance.event.on('pointerdown', (e, engineEvent) => {
        e.preventDefault?.();
        console.log('pointerdown', e, engineEvent);
        // 尝试设置 pointer capture，确保 pointermove/up 会持续发给 canvas
        if ('pointerId' in e && typeof canvas.setPointerCapture === 'function') {
          try { canvas.setPointerCapture(e.pointerId); } catch {}
        }

        const { x, y } = toCanvasXY(e);
        dragging = {
          id: instance.id,
          pointerId: ('pointerId' in e) ? e.pointerId : null,
          transform: instance.transform,
          offsetX: x - instance.transform.x,
          offsetY: y - instance.transform.y,
        };
      });
    }

    bindDrag(rect);
    bindDrag(circle);
    bindDrag(polyline);

    // 用全局 pointermove/up 做拖拽，不依赖 EventSystem 的“捕获”
    canvas.addEventListener('pointermove', (e) => {
      if (!dragging) return;
      if (dragging.pointerId != null && e.pointerId !== dragging.pointerId) return;
      e.preventDefault();
      const { x, y } = toCanvasXY(e);
      dragging.transform.x = x - dragging.offsetX;
      dragging.transform.y = y - dragging.offsetY;
    }, { passive: false });

    canvas.addEventListener('pointerup', (e) => {
      if (!dragging) return;
      if (dragging.pointerId != null && e.pointerId !== dragging.pointerId) return;
      dragging = null;
    });

    canvas.addEventListener('pointercancel', (e) => {
      if (!dragging) return;
      if (dragging.pointerId != null && e.pointerId !== dragging.pointerId) return;
      dragging = null;
    });

    engine.start();
  </script>
</body>

</html>
